
# 编译加速

- [编译加速](#编译加速)
  - [编译慢的原因](#编译慢的原因)
  - [修改代码加速编译](#修改代码加速编译)
    - [头文件中使用前置声明(不直接包含头文件)](#头文件中使用前置声明不直接包含头文件)
    - [使用 Pimpl 模式](#使用-pimpl-模式)
    - [高度模块化](#高度模块化)
    - [删除冗余头文件](#删除冗余头文件)
    - [注意 inline 和 template](#注意-inline-和-template)
  - [使用工具加速编译](#使用工具加速编译)
    - [预编译头文件(gch)](#预编译头文件gch)
    - [Unity Build](#unity-build)
    - [ccache](#ccache)
    - [target\_include\_directories](#target_include_directories)
  - [扩展硬件资源加速编译](#扩展硬件资源加速编译)
    - [并行编译](#并行编译)
    - [更好的磁盘](#更好的磁盘)
    - [分布式编译](#分布式编译)
  - [参考资料](#参考资料)

---

## 编译慢的原因

C++ 是基于 "头文件-源文件" 的编译模型。

在这种编译模型下，每个源文件作为一个编译单元，其所包含的头文件都会从硬盘读取一遍，而后解析一遍。

然后在编译时每个编译单元都会产生一个 obj 文件，这些 obj 文件被链接到一起形成目标。

链接这个过程很难被并行。

以上过程存在无数头文件的重复读取与解析以及密集的磁盘 I/O。

---

## 修改代码加速编译

---

### 头文件中使用前置声明(不直接包含头文件)

当我们 include 一个头文件时，由于头文件的"被包含"特性，这种效果可能会被无限放大。

所以，需要**尽可能使头文件精简**。

很多时候前置申明某个 namespace 中的类会比较痛苦，而直接 include 会方便很多，但头文件还是要尽可能精简。

类的成员、函数参数等也尽量使用引用、指针，为前置声明创造条件。

---

### 使用 Pimpl 模式

Pimpl 全称为 Private Implementation。

传统 C++ 类的接口与实现是混淆在一起的，而Pimpl这种做法使得**类的接口与实现完全分离**。

这样，只要类的公共接口保持不变，对类实现的修改只需编译该 cpp；同时，该类提供给外界的头文件也会精简许多。

---

### 高度模块化

模块化就是低耦合，就是尽可能的减少相互依赖。

1. 文件与文件之间：一个头文件的变化，尽量不要引起其他文件的重新编译。
2. 工程与工程之间：对一个工程的修改，尽量不要引起太多其他工程的编译。

这就要求头文件或者工程的内容一定要单一，不要什么东西都往里面塞，从而引起不必要的依赖。

以头文件为例，不要把**两个不相关的类**或者**没什么联系的宏**定义到一个头文件里。内容单一可以使包含他们的文件**不包含**不需要的内容。

在开发过程中经常遇到这种情况：

在某段时间内需要只在某个文件上开发或者调试。如果该文件比较大或者依赖该文件的文件比较多，则每次哪怕只改动一行，编译时间可能都很长。

解决这种问题的方法是：把该文件分拆成多个文件，让比较稳定的部分独立成一个文件，变动比较大的部分独立成一个文件。

这种方法有时可能违背代码设计模式的原则，所以只能用于调试或者开发中的不稳定阶段。

---

### 删除冗余头文件

冗余头文件主要有**未使用**和**重复包含**两种。

未使用头文件的删除主要针对 cpp 文件，因为头文件中某个 include 是否冗余需要看编译单元中是否使用了，从而很难界定。

[include-what-you-use](./include-what-you-use/include-what-you-use.md)

---

### 注意 inline 和 template

inline 和 template 是 C++ 中两种比较"先进"的机制，但是它们却又强制我们在头文件中包含实现。

这对增加头文件的内容，从而减慢编译速度有着很大的贡献。

使用之前，需要权衡一下。

---

## 使用工具加速编译

---

### 预编译头文件(gch)

把一些常用但不常改动的头文件放在预编译头文件中。这样在单个工程中就不需要在每个编译单元里多次加载和解析同一个头文件了。

[预编译头文件](./预编译头文件/预编译头文件.md)

---

### Unity Build

Unity Build 做法很简单，把所有的 cpp 包含到一个 cpp 中，然后只编译这一个 cpp。

这样我们就只有一个编译单元，意味着不需要重复加载和解析同一个头文件了。

同时只产生一个 obj 文件，所以在链接时也不需要密集的磁盘 I/O 了，速度估计能有**10倍**的提升。

---

### ccache

ccache 是 compiler cache 的缩写。

cache 通过缓存上一次编译的结果，使重新编译时在保持结果相同的情况下，极大的提高速度。

编译时系统会对比源代码与目标代码的时间来决定是否要重新编译，但这个方法并不完全可靠(比如使用更早版本的代码来编译)。

ccache判断的原则是文件内容，相对来讲要可靠的多。

[ccache](./ccache/ccache.md)

---

### target_include_directories

编译器定位头文件是根据提供的**头文件包含目录**进行搜索的。

可以想象，如果提供了100个包含目录，而某个头文件正好在第100个目录下，那定位它的过程将是非常痛苦的。

因此组织好你的包含目录，并尽量保持简洁。

在 CMake 中有 **include_directories(path)** 和 **target_include_directories(target path)** 两条添加头文件目录的命令。

- include_directories：**当前CMake文件中的目标**以及**在调用点之后添加的子目录中的目标**在编译时头文件包含目录都会有 path。
- target_include_directories：具有目标范围，将 path 添加到 target 的包含路径中。

如果所有目标都使用相关的包含目录，则需要 include_directories。

如果路径特定于目标或者希望更精细地控制路径的可见性，则需要 target_include_directories。

target_include_directories 还支持[限定符](../从可执行文件到库.md#public--private--interface)。

---

## 扩展硬件资源加速编译

---

### 并行编译

编译的时候**指定使用多核**，多核 CPU 下多个文件并行编译。

假设有 Project A 和 Project B，编译分别耗时 1 小时，且 A 依赖 B，那么将花费 2 小时。

如果使用增量式编译，我们可以同时分别编译 A 和 B，但 A 将在链接时失败。当 B 编译完成后，重新链接 A 即可。

---

### 更好的磁盘

编译速度慢很大一部分原因是磁盘I/O，那可以速度更快的磁盘。

---

### 分布式编译

一台机子的性能始终是有限的，利用网络中空闲的资源或者专门用来编译的服务器来帮助编译才能从根本上解决编译速度的问题，这就涉及到了分布式编译。

[distcc](./distcc/distcc.md)

---

## 参考资料

[C++加快编译速度的方法](https://blog.csdn.net/xhtchina/article/details/112801885)
