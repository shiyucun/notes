
# linux内核并发和竞态

- [linux内核并发和竞态](#linux内核并发和竞态)
  - [相关概念](#相关概念)
    - [并发](#并发)
    - [竞态](#竞态)
    - [共享资源](#共享资源)
    - [互斥访问](#互斥访问)
    - [临界区](#临界区)
  - [竞态解决方法](#竞态解决方法)
    - [中断屏蔽](#中断屏蔽)
    - [自旋锁](#自旋锁)
    - [衍生自旋锁](#衍生自旋锁)
    - [信号量(睡眠锁)](#信号量睡眠锁)
    - [原子操作](#原子操作)

## 相关概念

### 并发

多个执行单元同时发生。

### 竞态

多个执行单元同时对共享资源的访问，形成竞争的状态。

形成竞态的条件：

- 要有多个执行单元
- 要有共享资源
- 同时访问

产生情况：

- 单CPU的进程与进程之前的抢占
- 中断和进程
- 中断和中断
- 多核共享系统总线和IO

### 共享资源

软件上的全局变量或者硬件寄存器。

### 互斥访问

当一个执行单元在访问共享资源的时候，其他执行单元被禁止访问。

互斥访问的本质目的就是让访问共享资源的代码区域具有原子性，不可被别的任务打断。

### 临界区

访问共享资源的代码区域，例如：

```c
if (--open_cnt != 0) {
    printk("设备已被打开!\n");
    open_cnt++;
    return -EBUSY;
}
```

## 竞态解决方法

- 中断屏蔽
- 自旋锁
- 衍生自旋锁
- 信号量
- 原子操作

### 中断屏蔽

特点：

- 解决进程与进程之间、中断和进程之间、解决中断和中断之间的竞态
- 中断屏蔽保护的临界区要求执行的速度要快且不能进行休眠操作
- 中断的屏蔽和使能必须成对使用

利用中断屏蔽保护临界区的编程步骤：

1. 搞清楚哪些是共享资源
2. 搞清楚哪些代码属于临界区
3. 搞清楚临界区是否有休眠操作，代码执行速度是否够快，如果没有可以中断屏蔽
4. 在访问临界区之前屏蔽中断
5. 执行临界区
6. 执行完临界区以后，恢复中断

```c
unsigned long flags;

local_irq_disable();      // 屏蔽中断
local_irq_save(flags);    // 屏蔽中断，还能保存中断状态到flags中

local_irq_enable();          // 恢复中断
local_irq_restore(flags);    // 恢复中断和中断状态
```

### 自旋锁

特点：

- 自旋锁要附加在某个共享资源上
- 获取自旋锁的任务，在执行临界区的速度要快
- 获取自旋锁的任务，在执行临界区更不能做休眠操作
- 要获取自旋锁而没有获取自旋锁的任务将忙等待，直到有自旋锁的任务释放自旋锁
- 获取锁和释放锁要成对使用
- 能够解决多核引起的竞态问题
- 能够解决进程的抢占引起的竞态问题
- 对于中断引起的静态问题无法解决

数据类型：`spinlock_t`。

利用自旋锁保护临界区的编程步骤：

1. 搞清楚哪些是共享资源
2. 搞清楚哪些是临界区
3. 搞清楚临界区是否有休眠操作，如果没有，可以考虑使用自旋锁
4. 搞清楚共享资源是否被中断访问，如果没有，可以考虑使用自旋锁
5. 分配自旋锁对象：`spinlock_t lock`
6. 初始化自旋锁对象:`spin_lock_init(&lock)`
7. 访问临界区之前获取自旋锁
    - `spin_lock(&lock)`
        - 获取到自旋锁，此函数立即返回
        - 没有获取自旋锁，任务将在此函数中忙等待，直到持有自旋锁的任务释放自旋锁
    - `spin_trylock(&lock)`
        - 获取到自旋锁，此函数返回true
        - 没有获取自旋锁，不会忙等待，返回false
8. 访问临界区：执行要快，不能休眠
9. 访问临界区之后，释放自旋锁：`spin_unlock(&lock)`

### 衍生自旋锁

对于中断引起的竞态问题可以考虑使用衍生自旋锁，即衍生自旋锁能够解决所有的竞态问题。

特点：

- 基于自旋锁实现
- 附加了可以解决中断引起的竞态问题

利用衍生自旋锁解决竞态的编程步骤：

1. 搞清楚哪些是共享资源
2. 搞清楚哪些是临界区
3. 搞清楚临界区是否有休眠操作，如果没有，可以考虑使用衍生自旋锁
4. 分配自旋锁对象：`spinlock_t lock`
5. 初始化自旋锁对象：`spin_lock_init(&lock)`
6. 访问临界区之前屏蔽中断，获取自旋锁：`spin_lock_irqsave(&lock, flags)`
7. 访问临界区：执行要快，不休眠
8. 访问临界区以后，释放自旋锁：`spin_unlock_irqrestore(&lock, flags)`

```c
spinlock_t lock;
unsigned long flags;
spin_lock_irqsave(&lock, flags);       // 获取到自旋锁，立即返回；没有获取到自旋锁，忙等待
spin_unlock_irqrestore(&lock, flags);  // 释放自旋锁
```

### 信号量(睡眠锁)

特点：

- 信号量保护的临界区可以进行休眠操作
- 要获取信号量而没有获取信号量的进程将会进入休眠等待的状态；
- 持有信号量的任务访问临界区之后要唤醒之前休眠的进程，将信号量丢给这个进程
- 信号量的本质就是解决自旋锁包含的临界区不能休眠这个问题

信号量数据结构：`struct semaphore`

利用信号量保护临界区的编程步骤：

1. 搞清楚哪些是共享资源
2. 搞清楚哪些是临界区
3. 搞清楚临界区是否有休眠，如果有，必须使用信号量，不会考虑使用中断屏蔽或者自旋锁
4. 分配信号量对象：`struct semaphore sema`
5. 初始化信号量为互斥信号量：`sema_init(&sema, 1)`
6. 访问临界区之前获取信号量：
    - `down(&sema)`：
        - 如果正常获取到信号量，立即返回
        - 如果没有获取到信号量，进程将在函数中进入不可中断的休眠状态，不适用于中断
        - 进入休眠状态后只能由驱动主动唤醒，即使接收到了信号，也不会立即处理响应信号
    - `down_interruptible(&sema)`：
        - 正常获取到信号量返回 0
        - 没有获取到信号量，进程将进入可中断的休眠状态(信号或驱动都可以唤醒)
        - 判断返回值，0是驱动唤醒，且获取到信号量；非0，表明信号引起的唤醒，不适用于中断
    - `down_trylock(&sema)`说明：
        - 获取信号量返回true，否则返回false
        - 不会引起休眠，可以用于中断
7. 访问临界区
8. 释放信号量：`up(&sema)`，释放信号量并唤醒休眠的进程(又称驱动主动唤醒)

### 原子操作

操作过程具有原子性，能够解决所有的竞态问题。

分为**位原子操作**和**整型原子操作**。

位原子操作：本质就是内核提供了位原子操作的方法，利用这些方法对共享资源进行位操作，整个过程具有原子性。

```c
void set_bit(void *addr, int nr);
void clear_bit(void *addr, int nr);
void change_bit(void *addr, int nr);
int test_bit(void *addr, int nr);
```

整型原子操作：数据类型`atomic_t`。

整型原子操作编程步骤：

1. 分配整型原子变量：`atomic_t tv`
2. 初始化整型原子变量的值：`atomic_set(&tv, 1)`
3. 操作整形原子变量

整形原子操作的方法：

```c
int atomic_read(atomic_t *tv)                 // 读tv的值
void atomic_set(atomic_t *tv, int i)          // 设置tv的值为i
void atomic_add(int i, atomic *tv)            // tv的值增加i
void atomic_sub(int i, atomic *tv)            // tv的值减少i
void atomic_inc(atomic *tv)                   // tv的值加1
void atomic_dec(atomic *tv)                   // tv的值减1
int atomic_sub_and_test(int i, atomic_t *tv)  // tv的值减少i,且结果为0时返回true
int atomic_add_negative(int i, atomic_t *tv)  // tv的值增加i,且结果为负数时返回true
int atomic_add_return(int i, atomic_t *tv)    // tv的值增加i,且返回结果
int atomic_sub_return(int i, atomic_t *tv)    // tv的值减少i,且返回结果
int atomic_inc_return(atomic_t *tv)           // tv的值加1，且返回结果
int atomic_dec_return(atomic_t *tv)           // tv的值减1，且返回结果
int atomic_dec_and_test(atomic_t *tv)         // tv的值减1，且结果为0时返回true
int atomic_inc_and_test(atomic_t *tv)         // tv的值加1，且结果为0时返回true
```

整形原子操作和位原子操作都依赖内存屏障。
