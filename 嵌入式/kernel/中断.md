
# 中断

- [中断](#中断)
  - [硬件连接](#硬件连接)
  - [硬件处理流程(以按键为例,上升沿触发)](#硬件处理流程以按键为例上升沿触发)
  - [中断处理流程](#中断处理流程)
  - [中断的软件编程步骤](#中断的软件编程步骤)
  - [向linux内核添加硬件中断处理函数](#向linux内核添加硬件中断处理函数)
  - [内核对中断处理函数的要求](#内核对中断处理函数的要求)
  - [顶半部和底半部](#顶半部和底半部)
  - [底半部实现机制](#底半部实现机制)
    - [tasklet](#tasklet)
    - [工作队列](#工作队列)
  - [软中断](#软中断)
  - [软件定时器](#软件定时器)
    - [硬件定时器](#硬件定时器)
    - [HZ](#hz)
    - [jiffies](#jiffies)
    - [linux内核软件定时器](#linux内核软件定时器)

## 硬件连接

外设的中断信号不会直接发送到CPU，要经过中断控制器判断，最后决定是否产生一个中断信号。

中断控制器的功能：

- 能够使能或者屏蔽某个外设中断信号
- 能够设置中断的优先级
- 能够获取中断的触发标志
- 设置外设中断的触发方式：上升沿，下降沿等

## 硬件处理流程(以按键为例,上升沿触发)

1. 当人为按下按键：
    - 硬件的电信号由高电平向低电平跳变，产生下降沿电信号，这个电信号到达中断控制器
    - 中断控制器发现此电信号为下降沿，最后中断控制器不会给CPU发送一个中断信号
2. 当人为松开按键：
    - 硬件的电信号由低电平向高电平跳变，产生上升沿电信号，这个电信号到达中断控制器
    - 中断控制器发现此电信号为上升沿，这个电信号是合理的有效的中断信号
    - 中断控制器将会给CPU产生一个电信号
    - CPU接收到这个电信号开始进行中断的处理流程：跳转到异常向量表...

## 中断处理流程

请求中断→响应中断→关闭中断→保留断点→中断源识别→保护现场→中断服务子程序→恢复现场→中断返回

1. 某一中断源向CPU发起中断请求：
    - 对于外部中断CPU在当前指令最后一个时钟周期查询中断请求信号的有效性
    - 在系统开中断的情况下，CPU向中断源回送中断应答信号，系统进入中断响应周期
    - 系统内部中断源的中断请求CPU必须响应，自动取得中断服务子程序入口去执行中断服务子程序
2. CPU响应中断后，将状态标志寄存器压入堆栈保护
3. 将其中的中断标志位清除从而关闭中断
4. CPU将当前代码段地址和将要执行的下一条地址压入堆栈保护断点
5. CPU确定提出请求的中断源，获得中断向量号，在对应的中断向量表获得中断入口地址，装入对应寄存器
6. 将断点处各寄存器的内容压入堆栈保护现场
7. 此时程序跳转至中断服务子程序执行
8. 中断处理完毕，将堆栈各寄存器内容弹栈，恢复断点处各寄存器的值
9. 在中断服务子程序最后安排一条返回指令，程序转至被中断的程序继续执行。执行返回指令将：
    - 堆栈中寄存器的值弹出
    - 恢复主程序断点处地址值
    - 恢复标志寄存器的内容

## 中断的软件编程步骤

不管是裸板程序还是带操作系统的程序，中断编程都必须遵循以下几步骤：

1. 编写建立异常向量表的代码
2. 编写保护现场的代码
3. 编写中断服务程序(又称中断处理函数)
4. 编写恢复现场的代码

对于linux系统，linux内核已经实现步骤1、2、4。

对于驱动程序来说，只需向内核添加一个硬件中断对应的中断处理函数即可。

## 向linux内核添加硬件中断处理函数

```c
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long irqflags,
                const char *name, void *dev_id);
// 功能：申请硬件中断资源和注册这个硬件对应的中断处理函数，将来硬件中断触发，内核执行对应的中断处理函数。
// 参数说明：
//     irq: 待申请的中断号，对于CPU的硬件中断，每一个硬件中断在 linux 内核中都有唯一的软件编号(中断号)
//          编号从32开始，0~31内核保留
//     handler: 待注册的中断处理函数,一旦硬件中断给CPU产生中断信号，内核将来执行此中断处理函数
//     irqflags: 中断标志
//     name: 中断设备的名称, cat /proc/interrupts 调试时可以看中断是否注册成功
//     dev_id：给中断处理函数传递的参数，不传递指定为 NULL
// 中断标志(中断的触发标志)：
//     IRQF_TRIGGER_FALLING    下降沿触发中断
//     IRQF_TRIGGER_RISING     上升沿触发中断
//     IRQF_TRIGGER_HIGH       高电平触发中断
//     IRQF_TRIGGER_LOW        低电平触发中断
//     以上标志可以做位或元算，如下设置，按下和松开按键时都产生中断：
//         irqflags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING
// 对于内部中断(中断线集成在CPU内)，中断标志一般指定为0即可
```

中断处理函数：

```c
irqreturn_t 中断处理函数名(int irq, void *dev_id) {
    return IRQ_HANDLED; // 中断正常执行；
    // 或者
    return IRQ_NONE; // 中断不做处理
}
参数说明：
    irq：中断号
    dev_id：保存的是注册中断时传递的参数信息，使用时注意数据类型的转换
```

中断资源不再使用，一定释放中断：

```c
free_irq(int irq, void *dev_id);
// 功能：释放中断资源和卸载中断处理函数
// 参数说明：
//     irq：要释放的中断号
//     dev_id：给中断处理函数传递的参数信息，一定要和注册中断时传递的参数保持一致，否则内核崩溃
```

涉及头文件：

```c
#include <linux/irq.h>
#include <linux/interrupt.h>
```

## 内核对中断处理函数的要求

1. linux内核要求中断处理函数的执行速度要快，以让中断处理函数及时释放CPU资源给别的任务
2. linux内核要求中断处理函数不能做休眠操作
3. linux内核中断不隶属于任何进程，不参与进程间调度
4. 中断上下文：指中断的整个处理过程，跳转到异常向量表、保护现场、执行中断处理函数、恢复现场
5. 进程上下文：指进程的整个处理过程，进程创建、调度切换、睡眠、销毁
6. linux内核中断不允许直接和用户空间进行数据交互，如需与用户空间进行数据交互须配合系统调用

## 顶半部和底半部

顶半部：本质上还是中断处理函数，但只做原中断处理函数中紧急、耗时少的内容，过程不可被中断。

底半部：对应顶半部的延后处理函数，做原中断处理函数中耗时、不紧急的内容，CPU在合适的时候执行，可以被中断。

## 底半部实现机制

### tasklet

特点：

- 基于软中断实现
- 对应的延后处理函数同一时刻只能在一个CPU上运行
- 对应的延后处理函数工作在中断上下文中
- 对应的延后处理函数不能做休眠操作
- 优先级：硬件中断 > tasklet > 进程

数据结构：

```c
struct tasklet_struct {
    void (*func)(unsigned long);
    unsigned long data;
};
// 功能：描述抽象tasklet
// 成员：
//     func：对应的延后处理函数
//     data：给延后处理函数传递的参数，注意数据类型，一般传递指针
```

编程使用步骤：

```c
// 1. 分配初始化tasklet对象：
DECLARE_TASKLET(name, func, data);
// 参数：
//     name：tasklet对象名
//     func：延后处理函数
//     data：给延后处理函数传递的参数

// 2. 实现延后处理函数

// 3. 将 tasklet 对象添加到 tasklet，随即顶半部执行完毕，释放CPU
//    CPU在适当的时候执行 tasklet 对象对应的延后处理函数
tasklet_schedule(struct tasklet_struct *t);
// 参数：tasklet 对象的首地址
```

### 工作队列

"休眠"只能用于进程，工作队列可以解决 tasklet 对应的延后处理函数不能休眠的问题。

特点：

- 工作队列的延后处理函数工作在进程上下文
- 将来会参与进程的调度
- 优先级小于中断
- 工作队列对应的延后处理函数可以进行休眠操作

数据结构：

```c
struct work_struct {
    void (*func)(struct work_struct *work);
};
// 说明：
//     func：工作队列对应的延后处理函数，调度到的时候内核执行此函数
//     work：指向驱动分配初始化的工作对象
```

编程使用步骤：

1. 分配工作对象：`struct work_struct work`
2. 在驱动入口函数初始化工作对象,给工作添加一个延后处理函数：`INIT_WORK(&work, btn_work_func)`
3. 实现延后处理函数
4. 在顶半部登记工作对应的延后处理函数，将来内核执行对应的延后处理函数：`schedule_work(&work)`

## 软中断

软中断也是延后执行的一种手段。

- 延后处理函数工作在中断上下文中
- 延后处理函数能同时运行在多个CPU上
- 延后处理函数必须具备可重入性
- 延后处理函数只能静态编译到内核中，不能以模块的方式使用

## 软件定时器

### 硬件定时器

硬件定时器按照一定的周期，有规律的给CPU产生定时器中断。

周期可以人为通过软件编程来设置，对应的定时器中断处理函数将会被内核周期性的调用。

linux内核对应的定时器中断处理函数将会做如下工作：

- 更新系统的运行时间
- 更新实际时间(墙上时间)
- 检查当前进程的时间片，决定是否进行调度
- 检查是否有超时的软件定时器，如果有，处理这个软件定时器
- 做其他的资源统计等工作

### HZ

HZ为内核常数：

- ARM 中 HZ=100，表明一秒钟硬件定时器产生100次定时器中断
- X86 中 HZ=1000，表明一秒钟硬件定时器产生1000次定时器中断

硬件定时器的频率由HZ来设置。

### jiffies

jiffies是内核全局变量，类型为`unsigned long`，记录自开机以来产生了多少次定时器中断。

每发生一次定时器中断，jiffies加1(定时器中断处理函数中完成加1操作)。

内核一般用jiffies来表示当前时间。

### linux内核软件定时器

- 能够指定一个超时处理函数，一旦定时器到期，内核执行对应的超时处理函数
- 软件定时器基于软中断实现
- 超时处理函数工作在中断上下文中
- 超时处理函数不能做休眠操作
- 定时器到期以后，内核会删除定时器，超时处理函数只执行一次
- 软件定时器的检查是通过硬件定时器的中断处理函数中进行检查判断是否超时

数据结构：

```c
struct timer_list {
    unsigned long expires;
    void (*function)(unsigned long);
    unsigned long data;
};
// 功能：描述软件定时器
// 成员：
//     expires     超时时间，如超时时间间隔为5秒，则 expires = jiffies + 5*HZ
//     function    超时处理函数，一旦定时器到期，内核执行此函数
//     data        给超时处理函数传递的参数，一般传递指针
```

定时器软件编程步骤：

```c
#include <linux/timer.h>

// 1. 分配定时器对象
struct timer_list mytimer;

// 2. 初始化定时器对象

//初始化内核关心的字段
init_timer(&mytimer);

// 指定定时器的超时时间
// 可以使用 HZ 或者 msecs_to_jiffies
mytimer.expires = jiffies + 5*HZ; 
mytimer.expires = jiffies + msecs_to_jiffies(5000);

// 挂接超时处理函数
mytimer.function = mytimer_function;

// 挂接数据
int mydata = 0x55;
mytimer.data = (unsigned long)&mydata;

// 3. 注册添加，启动定时器，一旦启动，定时器开始倒计时
add_timer(&mytimer);  // 到期以后，内核执行超时处理函数，并且将定时器从内核中删除

// 4. 删除定时器(定时器未到期)：
del_timer(&mytimer);

// 5. 修改定时器
mod_timer(&mytimer, jiffies + 15*HZ);
```
