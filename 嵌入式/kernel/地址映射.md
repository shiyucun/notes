
# 地址映射

- [地址映射](#地址映射)
  - [用户空间和内核空间](#用户空间和内核空间)
  - [MMU地址映射](#mmu地址映射)
    - [MMU的作用](#mmu的作用)
    - [虚拟地址与物理地址的映射关系](#虚拟地址与物理地址的映射关系)
    - [内核访问所有物理内存](#内核访问所有物理内存)
    - [在内核空间直接访问硬件寄存器](#在内核空间直接访问硬件寄存器)
    - [将物理地址映射到内核虚拟地址](#将物理地址映射到内核虚拟地址)
    - [将物理地址映射到用户虚拟地址](#将物理地址映射到用户虚拟地址)
  - [在内核中分配内存](#在内核中分配内存)
    - [kmalloc/kfree](#kmallockfree)
    - [\_\_get\_free\_pages/free\_pages](#__get_free_pagesfree_pages)
    - [vmalloc/vfree](#vmallocvfree)
  - [全局数组](#全局数组)
  - [关于内核启动参数](#关于内核启动参数)

## 用户空间和内核空间

地址空间的范围是：0x00000000 - 0xFFFFFFFF，共4G。

用户空间进程独占前3G，0x00000000 - 0xBFFFFFFF；内核空间占后1G，0xC0000000 - 0xFFFFFFFF。

用户空间和内核空间所占大小可以在编译内核时进行修改。

用户程序和内核程序访问和操作的地址都是虚拟地址。CPU最终访问的地址是物理地址。

所以首先要保证这个物理地址和虚拟地址进行了映射。

## MMU地址映射

### MMU的作用

MMU是硬件逻辑单元，主要作用如下：

- 可以将虚拟地址转换成对应的物理地址
- 对地址的权限和有效性做检查
- 监测到地址权限不足或者无效产生异常

### 虚拟地址与物理地址的映射关系

用户3G虚拟地址空间从高地址到低地址依次划分为：栈、MMAP内存映射区、堆、BSS、DATA、TEXT。

用户虚拟地址和物理地址的映射采用动态映射，这种访问效率不高：

- 需要访问时，动态建立用户虚拟地址和物理地址的映射关系(页表)
- 不再使用时，将映射关系解除(删除页表)

内核虚拟地址和物理地址的映射采用静态映射。

静态映射就是内核启动初始化阶段，1G内核虚拟地址和物理内存进行一一映射：

物理地址(假设基地址为0) | 内核虚拟地址
--- | ---
0x0 | 0xC0000000
0x1 | 0xC0000001
0x2 | 0xC0000002
0x3 | 0xC0000003
... | ...

如上，可以得到虚拟地址和物理地址的线性关系：虚拟地址 = 物理地址 + 0xC0000000。

### 内核访问所有物理内存

如上静态映射完成后可直接访问内存，无需再动态创建映射关系，提高内存的访问效率。

但是如果一一映射，内核最多只能访问到1G的物理内存。

如果实际的物理内存大于1G，内核将1G虚拟地址空间划分为多个区域，实现让内核访问到所有的物理内存。

对于X86平台，1G虚拟内存区域的划分：

区域 | 说明
--- | ---
直接内存映射区 | 起始地址为0xC0000000，大小为896M(前提是物理内存大于1G)；<br>如果物理内存小于1G，直接内存映射区的大小就是物理内存的大小；<br>采用静态映射，即在内核启初始化的时候，内核就已经实现了物理内存和内核虚拟内存的一一映射关系；<br>内存访问效率高
动态内存映射区 | 起始地址为0xC0000000+896M(前提是物理内存大于1G)；<br>如果小于1G，起始地址为0xC0000000+物理内存大小；<br>大小默认为120M；<br>采用动态映射，需要访问某个物理内存时动态建立虚拟内存和物理内存的映射关系；<br>如果不再使用，一定要将映射关系解除，否则会造成动态内存映射区的有效内存越来越少；<br>采用动态映射即可让内核访问到所有的物理内存，但效率不高
永久内存映射区和固定内存映射区 | 本质一样，为了解决动态内存映射区内存访问效率不高的问题；<br>如果频繁的访问某个物理内存或者物理地址，可以将这个物理内存映射到永久或者固定内存区域，一旦映射，就不需要销毁(即使不用)，但是可以人为解除这种映射；<br>永久内存映射区会导致休眠，不能用于中断上下文，对应的映射函数：kmap；<br>固定内存映射区不会导致休眠，可以用于中断上下文，并且禁止了抢占，对应的映射函数：kmap_atomic

总结：直接内存映射区又称低端内存；动态内存映射区和永久内存映射区以及固定内存映射区称为高端内存。

### 在内核空间直接访问硬件寄存器

不管是在内核空间还是在用户空间，程序看到的地址都是虚拟地址，不是物理地址。

如果要访问外设，只需将这个外设的物理地址映射到用户虚拟地址或者内核虚拟地址上，之后访问虚拟地址，再通过MMU就能够访问到外设的物理地址。

注意：一个物理地址可以有多个虚拟地址。

### 将物理地址映射到内核虚拟地址

ioremap 函数可以将物理地址映射到内核虚拟地址。

```c
void *ioremap(unsigned long phys_addr, int size)
// 将物理地址映射到内核的虚拟地址上，访问这个内核虚拟地址就是在访问设备的物理地址
// 映射的内核虚拟内存位于动态内存映射区
// 参数：
//     phys_addr：设备的起始物理地址
//     size：要映射的设备物理内存的大小
// 返回值：物理地址对应的内核虚拟地址

void iounmap(void *vir_addr)
// 函数功能：解除地址映射
// 参数：映射的内核虚拟内存的起始地址
```

### 将物理地址映射到用户虚拟地址

mmap 函数可以将将物理地址映射到用户虚拟地址。

## 在内核中分配内存

### kmalloc/kfree

```c
void *kmalloc(size_t size, gfp_t flags)
// 函数功能：在低端内存区域分配内存，物理和虚拟地址都连续
// 参数说明：
//     size:指定分配内存的大小，最小为32字节，最大为4M(新内核)或者128K(老内核)
//     flags:指定分配内存时的行为，
//           GFP_KERNEL:内存不足时会导致分配进入休眠状态，不能用于中断上下文
//           GFP_ATOMIC:内存不足时不会导致休眠，而是立即返回，可以用于中断上下文
// 返回值：分配的内核虚拟起始地址

void kfree(void *addr)
// 函数功能：释放内存
```

### __get_free_pages/free_pages

```c
unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)
// 函数功能：在低端内存区域分配内存，物理地址和虚拟地址都连续
// 参数说明：
//     gfp_mask:指定分配内存时的行为，
//         GFP_KERNEL:内存不足时会导致分配进入休眠状态，不能用于中断上下文
//         GFP_ATOMIC:如果内存不足时不会导致休眠，而是立即返回，可以用于中断上下文
//     order:
//         order=0, 分配内存大小为1页
//         order=1, 分配内存大小为2页
//         order=2, 分配内存大小为4页
//         order=3, 分配内存大小为8页
//         ...
//         最小为1页，最大为4M，在linux系统中，一页为4K
// 返回值：分配的内核虚拟起始地址，注意数据类型的转换 

free_pages(unsigned long addr, int order)
// 函数功能：释放内存
```

### vmalloc/vfree

```c
void *vmalloc(size_t size)
// 函数功能：在动态内存映射区分配内存，虚拟地址连续，物理地址不一定连续，最大默认为120M，内存不足时会导致休眠
// 返回值：分配的内核虚拟起始地址，注意数据类型的转换

void vfree(void *addr)
// 函数功能：释放内存
```

## 全局数组

例如定义5M大小的全局数组：

```c
static char buf[5 * 1024 * 1024];                // (1)
static char buf[5 * 1024 * 1024] = {0x55,0xaa};  // (2)
```

定义(1)数组位于BSS段，不会影响可执行文件的大小。

定义(2)位于数据段，数据段的信息会影响到可执行文件的大小。

对于定义(2)：

- 如果代码中没有对这个数组进行访问操作，编译器将会把它当成垃圾优化掉
- 如果有访问操作，可执行文件的大小包括了这个数组的大小，最终导致模块的加载速度变慢

## 关于内核启动参数

内核的启动参数中添加`vmalloc=256M`，表明内核启动时，动态内存映射区由 120M 扩大到 256M。如：

```text
setenv bootargs root=/dev/nfs nfsroot=... vmalloc=256M
```

内核的启动参数中添加`mem=8M`，表明内核物理内存的最后8M预留给驱动。

驱动程序利用ioremap函数可以将这8M物理内存映射到内核的虚拟地址空间。如：

```text
setenv bootargs root=/dev/nfs nfsroot=... mem=8M
```
