
# 数据结构

- [数据结构](#数据结构)
  - [数据结构的主要运算](#数据结构的主要运算)
  - [线性表的特征](#线性表的特征)
  - [栈](#栈)
  - [队列](#队列)
  - [树](#树)
    - [二叉树](#二叉树)
    - [有序二叉树](#有序二叉树)
    - [二叉树遍历](#二叉树遍历)

数据结构是存储和组织数据的方式，描述元素之间的逻辑关系和物理关系。

逻辑结构分类：

- 集合结构
- 线性结构
- 树形结构(元素之间一对多的关系)
- 图形结构(图，元素之间多对多的关系)

物理结构分类：

- 顺序结构(地址连续的存储单元依次存放具有逻辑关系的元素)
- 链式存储(增加一个元素地址的指针)

## 数据结构的主要运算

- 建立(create)一个数据结构
- 消除(destroy)一个数据结构
- 从一个数据结构中删除(delete)一个数据元素
- 把一个数据元素插入(insert)到一个数据结构中
- 访问一个数据结构(access)
- 对一个数据结构(中的元素)进行修改(modify)
- 对一个数据结构进行排序(sort)
- 对一个数据结构进行查找(search)

## 线性表的特征

- 同一性(类型相同)
- 有穷性(个数有限)
- 有序性(直接前驱和直接后继)

## 栈

栈是一种后进先出(FILO, First In Last Out)的数据结构。

栈操作是受限的，分为硬堆栈和软堆栈：

- 硬堆栈
  - 利用CPU的某些寄存器组或类似硬件或使用内存特殊区域实现
  - 容量有限，速度快
- 软堆栈
  - 在内存中实现
  - 分为动态和静态两种方式

栈顶(top)允许操作，用指针top指向栈顶元素。

栈底(bottom)是固定端，表头。

空栈中无元素。

栈的存储：

- 顺序存储：存储空间连续，分为动态和静态，静态不能增大，动态可增大或减小
- 链式存储：即链栈，运算受限的单链表

栈的操作：创建、销毁、入栈、出栈、遍历、栈满、栈空。

两个栈实现一个队列：

1. 两个栈s1、s2，s1用于push，s2用于pop，变量back_elem存储最后添加的元素
2. 实现队列的push操作
    1. 每次进行添加操作，都会对栈s1进行添加元素
    2. s2不为空时要将s2的元素添加到是s1
    3. 再对s1添加元素，并对back_elem赋值
3. 实现队列的pop操作
    1. s2用于pop操作，首先判断栈s2是否为空
    2. 如果s2为空，则判断s1是否为空
    3. 如果s1也为空， 则输出错误信息，此时队列为空
    4. 如果s1不为空，则将栈s1中的所有数据存储到s2中
    5. 然后再执行pop操作，将队列的头元素删除
    6. 如果s2不为空， 则直接对s2执行pop操作
4. 实现队列的front操作
    - 方法同pop操作，只是在最后一步使用top返回值
5. 实现队列的back操作，变量back_elem保存着最后一个数据，直接返回
6. 实现队列的size、empty操作，就是对s1和s2分别执行该操作

[示例代码](./栈.md)。

## 队列

队列是一种先进先出(FIFO，First In First Out)的数据结构。

队列的操作：创建、销毁、入队、出队、查看队首元素、查看队尾元素，判空，判满、元素个数。

两个队列实现一个栈：

1. 使用两个队列q1、q2，q1做入栈操作、q2做出栈操作
2. 使用两个bool变量q1_used、q2_used，表示q1、q2是否在使用
    - 初始状态可以为`q1_used=true`、`q2_used=false`
3. 实现栈的push操作
    - 首先判断q1_used、q2_used，找出正在使用队列，将元素添加到队列中
4. 实现栈的pop操作
    - 首先判断q1_used、q2_used，找出正在使用的队列
    - 然后将正在使用的队列的最后一个元素外的其它元素添加到闲置队列
    - 然后删除最后一个元素
    - 最后修改q1_used、q2_used
5. 实现栈的top操作
    - 判断q1_used、q2_used，找出正在使用的队列
    - 利用该队列的back函数，返回栈头元素
6. 实现栈的size、empty操作，就是对正在使用的队列执行size、empty函数

[示例代码](./队列.md)。

## 树

由一个树根和很多分支组成一棵树(一对多)。

树可以为空，不为空就由很多没有交叉的分支构成，每一个分支都可以看作一棵树。

树可以有很多结点，每个结点包括：

- 数据内容
- 若干个指向后结点的指针
- 每个结点只有一个前结点和若干个后结点

### 二叉树

二叉树是最多只有两个分支的树。

如果除了最后一层叶子结点以外的结点都有两个分支，则称为满二叉树。

二叉树由很多结点组成，每个结点包含数据、左子树指针、右子树指针三个成员。

1. 二叉树每个结点最多有两个子结点
2. 每个子结点有且只有一个父结点，整个树只有一个根结点
3. 二叉树树具有递归的结构，可以拆分为很多小二叉树，可使用递归的方法处理：

```c++
处理(二叉树) {
  if( 空树 ) {
    直接处理;
  } else {
    处理根结点;
    处理左子树;
    处理右子树;
  }
}
```

[示例代码](./二叉树.md)。

### 有序二叉树

是指数据存储有序。

一般来讲，左子树 < 根结点 <= 右子树，也叫做二叉查找树。

### 二叉树遍历

先序遍历(DLR)：data left right，遍历次序是`根结点` --> `左子树` --> `右子树`。

中序遍历(LDR)：left data right，遍历次序是`左子树` --> `根结点` --> `右子树`。

后序遍历(LRD)：left right data，遍历次序是`左子树` --> `右子树` --> `根结点`。

中序遍历有序二叉树可以得到有序数。
