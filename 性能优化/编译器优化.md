
# 编译器编译选项优化

相关参考链接：

[编译器优化](https://en.wikipedia.org/wiki/Category:Compiler_optimizations)。

[编译器优化选项](https://gcc.gnu.org/onlinedocs/gcc-12.1.0/gcc/Optimize-Options.html)。

- [编译器编译选项优化](#编译器编译选项优化)
  - [优化级别](#优化级别)
  - [O1 优化](#o1-优化)
  - [O2 优化](#o2-优化)
  - [O3 优化](#o3-优化)

编译器提供 O1、O2、O3 三个级别的优化，每个级别的优化都完成不同的工作。

以下每个优化命令都可以通过命令行选项`-f`单独使用。

## 优化级别

- O1：提供基础级别的优化
- O2：提供更加高级的代码优化，会占用更长的编译时间
- O3：提供最高级的代码优化

## O1 优化

这个级别试图执行9种单独的优化功能：

1. -fdefer-pop：优化函数返回时的操作，函数返回时推迟弹出输入值堆栈
2. -fmerge-constans：试图合并相同的常量，会导致编译时间变长
3. -fthread-jumps：
   - 优化汇编代码中的条件和非条件分支
   - 确定多个跳转之间的最终目标并且把第一个跳转重新定向到最终目标
4. -floop-optimize：
   - 优化生成的汇编语言中的循环，提高应用程序的性能
   - 优化跳出循环的条件分支，以减少分支影响
5. -fif-conversion：通过条件传送、设置标志或使用运算技巧来减少条件分支
6. -fif-conversion2：结合更加高级的数学特性，减少条件分支
7. -fdelayed-branch：
   - 根据指令周期时间重新排列指令
   - 将尽可能多的指令移动到条件分支前，以充分利用处理器缓存
8. -fguess-branch-probability：
   - 预测条件分支最可能的结果，并且相应的移动指令，与延迟分支技术类似
   - 因为在编译时预测并调整分支，所以两次编译相同的代码很可能会产生不同结果
9. -fcprop-registers：
   - 函数中寄存器分配给变量后再次执行检查以减少调度依赖性(避免两个段依赖相同的寄存器)
   - 删除不必要的寄存器复制

## O2 优化

结合 O1 所有优化技术，再加上以下优化：

1. -fforce-mem：
   - 任何指令使用变量前，强制把存放在内存中的变量复制到寄存器中
   - 对于只涉及单一指令的变量，优化效果并不明显
   - 对于很多指令中都涉及的变量，优化效果显著(必须是数学操作)
   - 访问寄存器比访问内存快
2. -foptimize-sibling-calls：
   - 处理函数调用
   - 通常递归的函数调用可以被展开为一系列一般的指令，不使用分支
   - 处理器的指令缓存能够加载展开的指令并进行处理
   - 加载展开的指令比保持为分支操作的函数调用比更快
3. -fstrength-reduce：
   - 强度降低，某些耗时操作会被等价的更快速的操作替代
   - 如加法替代乘法、乘法替换幂运算等
4. -fgcse：
   - 分析生成的汇编代码，并结合通用片段，消除冗余代码段
   - 如果代码使用计算性的goto，gcc指令推荐使用-fno-gcse选项
5. -fcse-follow-jumps：扫描程序中的跳转指令，查找通过任何其它路径都不会执行的代码
6. -frerun-cse-after-loop：循环优化后重新进行子表达式消除
7. -fdelete-null-pointer-checks：删除进行空指针检查的代码
8. -fregmove：
   - 编译器试图重新分配 mov 指令中使用的寄存器
   - 将重新分配的寄存器作为其它指令的操作数，以最大化捆绑寄存器数量
9. -fschedule-insns：
   - 编译器将试图重新安排指令，以消除等待数据提高性能。
   - 对于进行浮点运算有延迟的处理器，使处理器在等待浮点结果时加载其它指令
10. -fsched-interblock：
    - 使编译器能够跨越指令块调度指令
    - 这样可以非常灵活地移动指令以便高效的执行代码
11. -fcaller-saves：
    - 发出额外的指令保存和恢复函数调用前后的寄存器
    - 只有当编译器判断这样能够产生更好的代码时才会真正生效
12. -fpeephole2：允许进行特定于机器的窥孔优化
    - 窥孔优化：
      - 一种很局部的优化方式
      - 作用在一个基本块或者多个基本块中
      - 针对已经生成的代码，结合CPU指令特点
      - 通过可能带来性能提升的转换规则或者通过整体分析，进行指令转换，提升性能
      - 代码转换很局部、很小，但可能会带来很大的性能提升
      - 窥孔，可以认为是一个滑动窗口
      - 编译器在实施窥孔优化时，仅分析窗口内的指令。
      - 每次转换后，可能还会暴露相邻窗口之间的某些优化机会，所以可以多次调用窥孔优化
13. -freorder-blocks：允许重新排列指令块以便改进分支操作和代码局部性
14. -fstrict-aliasing：
    - 启用严格别名规则，别名就是同一内存地址有不同的名称
    - 编译器假定相同的内存地址绝不会存放不同类型的数据，否则就是破坏了严格别名规则
    - 启用该规则后，如果违反了其中的规则，运算结果是不可知的
    - [Understanding C/C++ Strict Aliasing](http://dbp-consulting.com/tutorials/StrictAliasing.html)
    - [What is the Strict Aliasing Rule and Why do we care?](https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8)

## O3 优化

整合了第一和第二级别中的优化技巧，还包括以下优化:

1. -finline-functions：
   - 不为函数创建单独的汇编语言代码，而是把函数代码在调用程序中展开
   - 对于多次被调用的函数，为每次函数调用复制函数代码
   - 这样回到导致目标体积变大，但通过充分利用指令缓存、减少函数调用，可以提高性能

2. -fweb：
   - 构建用于保存变量的伪寄存器网络
   - 伪寄存器包含数据，就像他们是寄存器一样
   - 伪寄存器可以使用其它各种优化技术进行优化

3. -fgcse-after-reload：
   - 在完全重新加载生成和优化后的汇编语言代码后执行第二次 gcse 优化
   - 消除不同优化方式创建的任何冗余段
